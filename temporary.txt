# Discord Race Prediction View
class PredictionView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=300)

        #shared state
        self.pos1 = None
        self.pos2 = None
        self.pos3 = None
        self.pole = None
        self.fastest_lap = None

        #dropdowns with exlusitivity
        self.pos1_select = PositionSelect("pos1",self)
        self.pos2_select = PositionSelect("pos2",self)
        self.pos3_select = PositionSelect("pos3",self)

        #dropdowns without exclusivity
        self.pole_select = SimpleSelect("pole",self)
        self.fastest_lap_select = SimpleSelect("fastest_lap",self)

        #add items to the view
        for item in[
            self.pos1_select,
            self.pos2_select,
            self.pos3_select,
            self.pole_select,
            self.fastest_lap_select,
        ]:
            self.add_item(item)

    def available_drivers(self, current_pos):
        used = {self.pos1, self.pos2, self.pos3}
        used.discard(None)
        
        if current_pos:
            used.discard(getattr(self, current_pos))

        return [d for d in DRIVERS if d not in used]
    
    def refresh_dropdowns(self):
        self.pos1_select.update_options()
        self.pos2_select.update_options()
        self.pos3_select.update_options()

#Discord Race Prediction Selects
class PositionSelect(discord.ui.Select):
    def __init__(self, position, parent):
        self.position = position
        self.prediction_view = parent
        super().__init__(
            placeholder=f"Select {position.upper()}",
            options =[discord.SelectOption(label=d) for d in DRIVERS],
            min_values=1,
            max_values=1,)
    
    def update_options(self):
        available = self.prediction_view.available_drivers(self.position)
        self.options = [discord.SelectOption(label=d) for d in available]
        if getattr(self.prediction_view, self.position):
            self.options.append(discord.SelectOption(label=getattr(self.prediction_view, self.position), default=True))
    
    async def callback(self, interaction: discord.Interaction):
        selected_driver = self.values[0]
        setattr(self.prediction_view, self.position, selected_driver)
        self.prediction_view.refresh_dropdowns()
        await interaction.response.edit_message(view=self.parent)

class SimpleSelect(discord.ui.Select):
    def __init__(self, field, parent):
        self.field = field
        self.prediction_view = parent
        super().__init__(
            placeholder=f"Select {field.replace('_', ' ').title()}",
            options =[discord.SelectOption(label=d) for d in DRIVERS],
            min_values=1,
            max_values=1,)
        
    async def callback(self, interaction: discord.Interaction):
        setattr(self.prediction_view, self.field, self.values[0])
        await interaction.response.edit_message(view=self.prediction_view)
_____________________________________________________________________________________

await interaction.response.send_message(
        "Predictions are closed.",
        ephemeral = True
)
______________________________________________________________________________________

class SubmitButton(discord.ui.Button):
    def __init__(self, parent):
        self.prediction_view = parent
        super().__init__(label="Submit Predictions", style=discord.ButtonStyle.green)

    async def callback(self, interaction: discord.Interaction):
        now = datetime.now(timezone.utc)

        if not predictions_open(
            now,
            lock_time,
           ):
            await interaction.response.send_message(
                "Predictions are closed.",
                ephemeral=True)
            return
        user_id = interaction.user.id
        main_predictions[user_id] = {
            "User_ID": interaction.user.id,
            "Pos1": self.parent.pos1,
            "Pos2": self.parent.pos2,
            "Pos3": self.parent.pos3,
            "Pole": self.parent.pole,
            "Fastest_Lap": self.parent.fastest_lap,
        }

        #Now store in DB
        await interaction.response.send_message(
            f"Your predictions have been recorded: \n '''{list(main_predictions.items())}'''",
              ephemeral=True)
        
        self.parent.stop()
________________________________________________________________________________________________________________________

def refresh_race_cache(now=None):
    if now is None:
        now = datetime.now(timezone.utc)
    # Get timing of the next Quali session
    schedule = fastf1.get_event_schedule(2026)
    schedule['Session1DateUtc'] = pd.to_datetime(schedule['Session1DateUtc'], utc=True)
    future_races = schedule[schedule['Session1DateUtc'] > now]
    next_race = future_races.iloc[0]
    cache_race = future_races.iloc[1] if len(future_races) > 1 else None

    race_number = int(next_race["RoundNumber"])
    race_name = next_race["EventName"]
    location = next_race["Location"]
    country = next_race["Country"]
    event_format = next_race["EventFormat"]


    # Check if it's a sprint weekend using EventFormat column
    is_sprint = "sprint" in event_format.lower()

    lock_time = next_race["Session4DateUtc"]

    sprint_lock_time = (
        next_race["Session2DateUtc"] if is_sprint else None
    )

    next_refresh = (
        cache_race["Session1DateUtc"] - timedelta(days=3)
        if cache_race is not None
        else None
    )

    return {
        "race_number": race_number,
        "race_name": race_name,
        "location": location,
        "country": country,
        "event_format": event_format,
        "is_sprint": is_sprint,
        "lock_time": lock_time,
        "sprint_lock_time": sprint_lock_time,
        "next_refresh": next_refresh,
    }

_____________________________________________________________________________________

async def poll_results_loop(bot):
    await bot.wait_until_ready()
    loop = asyncio.get_running_loop()

    while not bot.is_closed():
        # Run FastF1 safely
        race_data = await loop.run_in_executor(None, race_results)

        if race_data:
            conn = get_connection()
            saved = save_race_results(conn, race_data)

            if saved:
                sprint_data = await loop.run_in_executor(None, sprint_results)
                if sprint_data:
                    save_sprint_results(conn, sprint_data)

                await score_race(race_data["race_number"])

        await asyncio.sleep(600/)  # 10 minutes
_____________________________________________________________________________________

async def final_champions_loop(bot, check_interval: int = 3600):
    await bot.wait_until_ready()
    loop = asyncio.get_running_loop()

    while not bot.is_closed():
        # Run the check safely in executor
        result = await loop.run_in_executor(None, get_final_champions_if_ready)

        if result:
            # Ergast results are plain strings
            wdc_winner, wcc_winner = result

            # Convert to user prediction format
            wdc = wdc_winner[:3].upper()   # e.g., "hamilton" -> "HAM"
            wcc = wcc_winner.capitalize()  # e.g., "mercedes" -> "Mercedes"

            conn = get_connection()

            # Save final champions in DB
            save_final_champions(conn, wdc, wcc)
            #print(f"Final champions recorded: WDC={wdc}, WCC={wcc}")

            score_final_champions()
            return

        await asyncio.sleep(check_interval)
_____________________________________________________________________________________
def get_race_end_time(now = None, year=None):
    if year is None:
        year = YEAR

    if now is None:
        now = datetime.now(timezone.utc)
    #print("Fetching F1 schedule...")
    # Fetch schedule once
    schedule = fastf1.get_event_schedule(year)
    #print("Schedule fetched!")

    # Convert only the columns we need to UTC-aware datetime
    date_cols = ["Session5DateUtc"]
    for col in date_cols:
        schedule[col] = pd.to_datetime(schedule[col], utc=True, errors='coerce')#.dt.to_pydatetime()

    # Keep only future races
    future_races = schedule[schedule['Session5DateUtc'] > now]

    if future_races.empty:
        return None  # no upcoming races
    #print (future_races)
    next_race = future_races.iloc[0]
    race_end_time_panda = next_race["Session5DateUtc"]
    race_end_time = race_end_time_panda.to_pydatetime().astimezone(timezone.utc)
    race_end_time += timedelta(hours = 12)
    return race_end_time
_____________________________________________________________________________________
class PredictionSelect(discord.ui.Select):
    def __init__(self, index, current_selection=None):
        self.index = index
        # Build options and mark the current selection as default if provided
        options = [
            discord.SelectOption(label=d, value=d, default=(d == current_selection))
            for d in DRIVERS
        ]
        super().__init__(
            placeholder=f"Pick driver for {PREDICTIONS[index]}",
            options=options
        )

    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        now = get_now()

        if not predictions_open(
            now,
            RACE_CACHE
           ):
            self.view.disable_all()
            await interaction.edit_original_response(
                content="ðŸ”’ Predictions are closed.",
                view=self.view
            )
            return
        
        user_id = interaction.user.id
        if user_id not in user_predictions:
            user_predictions[user_id] = [None] * 5

        selected_driver = self.values[0]
        previous = user_predictions[user_id][self.index]

        # For Positions 1-3, dynamically update other selects to prevent duplicates
        if self.index < 3:
            # other selections for positions 0-2 excluding this index
            other_selected = {v for i, v in enumerate(user_predictions[user_id][:3]) if v and i != self.index}
            # If another position already has this driver and it's not this position's previous value, reject
            if selected_driver in other_selected and selected_driver != previous:
                await interaction.followup.send(
                    f"âŒ {selected_driver} already selected for Positions 1-3. Pick a different driver!",
                    ephemeral=True
                )
                return

            # store the new selection
            user_predictions[user_id][self.index] = selected_driver
            save_race_predictions(
                interaction.user.id,
                interaction.user.name,
                int(RACE_CACHE.get("race_number")),
                RACE_CACHE.get("race_name"),
                user_predictions[user_id]
            )

            # recompute taken drivers for positions 0-2
            taken = {v for v in user_predictions[user_id][:3] if v}

            # update options on other select children in this view
            for child in list(self.view.children):
                if isinstance(child, PredictionSelect) and child.index < 3:
                    # allow the child's own current choice to remain visible
                    curr = user_predictions[user_id][child.index]
                    new_options = []
                    for d in DRIVERS:
                        if d not in taken or d == curr:
                            new_options.append(discord.SelectOption(label=d, value=d, default=(d == curr)))
                    child.options = new_options

            # edit the message to apply the updated view
            await interaction.edit_original_response(view=self.view)
            #print(f"{interaction.user.name}'s predictions: {user_predictions[user_id]}")
            return

        # Fastest Lap and Pole can repeat drivers
        user_predictions[user_id][self.index] = selected_driver
        save_race_predictions(
                interaction.user.id,
                interaction.user.name,
                int(RACE_CACHE.get("race_number")),
                RACE_CACHE.get("race_name"),
                user_predictions[user_id]
            )
        #print(f"{interaction.user.name}'s predictions: {user_predictions[user_id]}")
        #await interaction.response.defer(ephemeral=True)

class PredictionView(discord.ui.View):
    def __init__(self, user_id=None):
        super().__init__(timeout=300)
        for i in range(5):
            current = None
            if user_id and user_id in user_predictions:
                current = user_predictions[user_id][i]
            self.add_item(PredictionSelect(i, current_selection=current))

        now = get_now()
        if not predictions_open(now, RACE_CACHE):
            self.disable_all()

    def disable_all(self):
        for child in self.children:
            child.disable = True

@bot.tree.command(name="race_predict", description="Make your race predictions")
async def predict(interaction: discord.Interaction):
    try:
        await interaction.response.defer(ephemeral=True)
        await interaction.followup.send(
            f"Make your predictions for the {RACE_CACHE.get("race_name")}:",
            view=PredictionView(interaction.user.id),
            ephemeral=True)
    except Exception as e:
        print(e)
_____________________________________________________________________________________
@tasks.loop(minutes=60/TIME_MULTIPLE)
async def bold_predictions_publisher():
    #print("Bold loop tick")

    try:
        race_number = RACE_CACHE.get("race_number")
        race_name = RACE_CACHE.get("race_name")
        lock_time = RACE_CACHE.get("lock_time")

        if not race_number or not lock_time:
            return

        now = get_now()
        publish_time = lock_time - timedelta(days=2)

        print(f"NOW: {now}")
        print(f"LOCK TIME: {lock_time}")   

        if now < publish_time or now > lock_time:
            return

        # fetch predictions
        preds = fetch_bold_predictions(race_number)
        print("PRED COUNT:", len(preds))

        # render message
        lines = [
            f"**Bold Predictions â€” {race_name}**",
            "",
            f"Submissions lock in <t:{int(lock_time.timestamp())}:R>",
            ""
        ]

        if preds:
            for username, prediction in preds:
                lines.append(f"â€¢ **{username}** â€” {prediction}")
        else:
            lines.append(f"No predictions for the {race_name} yet.")

        content = "\n".join(lines)

        # 1ï¸âƒ£ fetch channel ID from DB
        channel_id = get_prediction_channel(guild.id)
        if not channel_id:
            # optional: log or notify
            print(f"No prediction channel set for guild {guild.id}")
            return

        # 2ï¸âƒ£ get live channel object
        channel = guild.get_channel(channel_id)
        if not channel:
            print(f"Configured channel {channel_id} no longer exists in guild {guild.id}")
            return
    
        # ðŸ”‘ THIS is the important part
        if not hasattr(bold_predictions_publisher, "message"):
            msg = await channel.send(content)
            await msg.pin()
            bold_predictions_publisher.message = msg
        else:
            await bold_predictions_publisher.message.edit(content=content)

    except Exception as e:
        print("BOLD LOOP ERROR:", e)
_____________________________________________________________________________________
def update_leaderboard():
    with db_lock:
        conn = get_connection()
        try:
            cur = conn.cursor()
            
            # First, let's see what we're combining
            cur.execute("""
                SELECT user_id, username, points, 'race_scores' as source FROM race_scores
                UNION ALL
                SELECT user_id, username, points, 'final_scores' as source FROM final_scores
                UNION ALL
                SELECT userid AS user_id, username, points, 'total_force_points' as source FROM total_force_points
                ORDER BY user_id, source;
            """)
            
            all_data = cur.fetchall()
            #print("\n=== All data before grouping ===")
            #for row in all_data:
                #print(f"user_id: {row[0]}, username: {row[1]}, points: {row[2]}, source: {row[3]}")
            
            # Now do the actual update
            cur.execute("DELETE FROM leaderboard;")
            cur.execute("""
                WITH combined AS (
                    SELECT user_id, username, points FROM race_scores
                    UNION ALL
                    SELECT user_id, username, points FROM final_scores
                    UNION ALL
                    SELECT userid AS user_id, username, points FROM total_force_points
                )
                INSERT INTO leaderboard (user_id, username, total_points)
                SELECT
                    user_id,
                    MAX(username) AS username,
                    SUM(points) AS total_points
                FROM combined
                GROUP BY user_id
                ORDER BY total_points DESC;
            """)
            
            # Check what got inserted
            cur.execute("SELECT user_id, username, total_points FROM leaderboard ORDER BY total_points DESC;")
            results = cur.fetchall()
            #print("\n=== Leaderboard after update ===")
            for row in results:
                print(f"user_id: {row[0]}, username: {row[1]}, total_points: {row[2]}")
            
            conn.commit()
            cur.close()
        except Exception as e:
            conn.rollback()
            print("Error updating leaderboard:", e)
            import traceback
            traceback.print_exc()
        finally:
            conn.close() 
_____________________________________________________________________________________
async def poll_results_loop(bot):
    await bot.wait_until_ready()
    loop = asyncio.get_running_loop()

    while not bot.is_closed():
        try:
            race_end_time = get_race_end_time(get_now())

            if race_end_time is None:
                print("No upcoming races found, season may be over. Waiting 24 hours...")
                await asyncio.sleep(24 * 60 * 60 / TIME_MULTIPLE)
                continue

            delay = (race_end_time - get_now()).total_seconds()
            
            # Wait until race ends, checking periodically
            while delay > 0:
                print(f"Waiting {delay/3600/TIME_MULTIPLE:.2f} hours until next race ends...")
                await asyncio.sleep(min(delay / TIME_MULTIPLE, 600 / TIME_MULTIPLE))
                # Recalculate in case something changed
                race_end_time = get_race_end_time(get_now())
                delay = (race_end_time - get_now()).total_seconds()
                continue 
            
            # If race_end_time became None, restart from top
            if race_end_time is None:
                continue
            
            # If we get here, delay <= 0, meaning race has ended
            print("Race has ended, fetching results...")
            race_data = await loop.run_in_executor(None, race_results)

            if race_data:
                race_num = race_data['race_number']
                
                # Check if already scored
                existing_scores = safe_fetch_one(
                    "SELECT 1 FROM race_scores WHERE race_number = %s LIMIT 1",
                    (race_num,)
                )
                
                if existing_scores:
                    print(f"Race {race_num} already scored.")
                    await asyncio.sleep(24 * 60 * 60 / TIME_MULTIPLE)
                    continue
                
                print(f"Processing race {race_num}...")
                save_race_results(race_data)
                
                sprint_data = await loop.run_in_executor(None, sprint_results)
                if sprint_data:
                    save_sprint_results(sprint_data)
                
                print(f"Scoring race {race_num}...")
                score_race(race_num)
                print(f"Race {race_num} scored successfully!")
                
                for guild in bot.guilds:
                    update_leaderboard(guild.id)
                print(f"Leaderboard updated successfully!")

                 # CRITICAL: Sleep before checking for next race
                print("Sleeping 24 hours before checking for next race...")
                await asyncio.sleep(24 * 60 * 60 / TIME_MULTIPLE)
            
        except Exception as e:
            print(f"Error in poll_results_loop: {e}")
            import traceback
            traceback.print_exc()
            await asyncio.sleep(60 * 60 / TIME_MULTIPLE)